import datetime
from Crypto.Cipher import AES 
from Crypto.Hash import SHA256

def create_key():

    # AES only excepts key lengths of 16,24,32 byte so use SHA256 to stretch key to 32 byte value
    password = datetime.datetime.today() # generate the current date and time as a datetime object 
    password = str(password) #convert the datetime object to a string so we can hash it
    hash_obj = SHA256.new(password.encode('utf-8')) #use the encode feature to turn the vairble password from a string to bytes. Actually it will be bytes but techically will be a type Sha256 object
    hkey= hash_obj.hexdigest() # we are taking the hashed datetime and making it into a hexdigest which will be len(64)
    hkey= hkey[len(hkey)::-2] # we are reversing the hexdigest and stepping by 2 just for added security

    hkey = hkey.encode('utf-8')

    iv = hash_obj.digest() # we are creating an iv from the hashed datetime, and we are using digest instead of hexdigest so the iv and hkey are not too similar. 
    iv = iv[len(iv)::-2] # reverse the iv (the hash_obj that's been digested) and slice the index by increments of 2 to generate an len(16) iv.

    # random iv generated by datetime hash. IV must be blocksize bytes long. If statements will ensure iv is blocksize long. 
    # this whole if statement used to add padding to inputted iv. I could delete it but keeping it acts as a safeguard incase the iv
    # is ever not len(16) which I can't imagine why that would ever happen but still.
    if len(iv) == 16:
        if len(hkey) == 32:
            pass
            # print("file encrypted successfully")
    elif len(iv) > 16:
        iv = iv[0:16]
    elif len(iv)< 16:
        while len(iv) < 16:
            iv = iv + "{"

    with open('key.txt','wb') as f:
        f.write(hkey)

    with open('iv.txt','wb') as x:
        x.write(iv)

create_key()
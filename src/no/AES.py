from Crypto.Cipher import AES 
from Crypto.Hash import SHA256
import datetime

'''
Notes for the group:
I commented almost every line to make the code really easy to read. 
for the script to work correctly the file must be in the same folder. We can get around this later by specfying a path. 
I tested the script on .docx, .odt, .pdf, .jpg, .png, and .gif files. For word document type files (.docx, .odt, etc.) the file encrypts and decrypts perfectly.
For other file types the encrypt function will make the file non-readable (e.g. if I encrypt a jpeg, the encrypted jpeg won't even be recognized by the system as a jpeg and cannot be viewed)
This should still suffice as encryption since malicous actors wouldn't be able to see the contents of the file. 
They also cannot decrypt without the key, encryption alogorithm mode used, and iv.
The decryption works flawlessly for all file types. 
Executing the file will automatically create the encrypted and decrytped version of the file
I can sepearte these functions into two different documents in the future if needed.

UPDATED:
I changed the password and iv to be generated from date time and then hashed and then digested and sliced if needed.
Now we require no user input to create iv and password
I used datetime which provides current date and time cause just using date or just using time would provide opportunity 
for ivs and passwords to be the same and certain points of the day or on certain days. This should not be an issue using datetime
The only other thing I can think of that might be a problem is that when these scripts are run, the file is simultaneously encrypted and decrypted
I can seperate this into two steps if needed, but to do this I will have to write a code to create a file to store name of file hashed 
(or maybe hashed name of file),ivs, passwords, and encrytpion typed used. 
'''

# AES only excepts key lengths of 16,24,32 byte so use SHA256 to stretch key to 32 byte value
password = datetime.datetime.today() # generate the current date and time as a datetime object 
password = str(password) #convert the datetime object to a string so we can hash it
hash_obj = SHA256.new(password.encode('utf-8')) #use the encode feature to turn the vairble password from a string to bytes. Actually it will be bytes but techically will be a type Sha256 object
hkey= hash_obj.hexdigest() # we are taking the hashed datetime and making it into a hexdigest which will be len(64)
hkey= hkey[len(hkey)::-2] # we are reversing the hexdigest and stepping by 2 just for added security

hkey = hkey.encode('utf-8')

iv = hash_obj.digest() # we are creating an iv from the hashed datetime, and we are using digest instead of hexdigest so the iv and hkey are not too similar. 
iv = iv[len(iv)::-2] # reverse the iv (the hash_obj that's been digested) and slice the index by increments of 2 to generate an len(16) iv.

# random iv generated by datetime hash. IV must be blocksize bytes long. If statements will ensure iv is blocksize long. 
# this whole if statement used to add padding to inputted iv. I could delete it but keeping it acts as a safeguard incase the iv
# is ever not len(16) which I can't imagine why that would ever happen but still.
if len(iv) == 16:
    if len(hkey) ==32:
        print("file encrypted successfully")
elif len(iv) > 16:
    iv = iv[0:16]
elif len(iv)< 16:
    while len(iv) < 16:
        iv = iv + "{"

file = 'MonsterHunter.jpg' # name of file to be encrypted
encrypted_file  = 'Encrypted' + ' ' + file #name the file to be encrytpted Encrypted + a space + the name of the inital file
decrypted_file = 'Decrypted' + ' ' + file #name the file to be decrytpted Decrypted + a space + the name of the inital file

def encrypt_file(file): # make encryption function
    with open(file, 'rb') as f: # file is the file to be encrypted we defined above. 'rb' stands for read bytes
        original_file = f.read()    # will read every line of the file
    BLOCK_SIZE = 16 # Block size is dependednt on encryption algorthim used for AES it is 16
    PAD = b'{' # the b is like the bytes version of the string. This will pad the file with "{" until it has symmetric block sizes of 16 bytes
    padding = lambda x: x + (BLOCK_SIZE-len(x) % BLOCK_SIZE) * PAD # will ensure the file is padded if it is not already in blocks of 16 bytes. See notes if this line does't make sense
    cipher= AES.new(hkey,AES.MODE_CBC,iv) #standard notation for encryption is [encryption method used].new(key,mode,iv) key = hkey, mode= cbc, iv= iv
    result = cipher.encrypt(padding(original_file)) # encrypt original file with padding. Techincally we are actually encrypting a copy of the original file. Might need to delete original file
    with open(encrypted_file,'wb') as e: #create a file with same name as before plus encrypted and enable it to be editted
        e.write(result) # write result, which is our encyrption to our newly created file
    
cipher_text = encrypt_file(file) # this will convert file to bytes. It is no longer a string. Will create encrypted file

def decrypt_file(cipher_text): #make decryption function
    with open(encrypted_file,'rb') as f: # file is the file to be encrypted we defined above. 'rb' stands for read bytes
        not_original_file = f.read() # will read every line of the file
    decipher = AES.new(hkey,AES.MODE_CBC,iv) #standard notation for decryption is [encryption method used].new(key,mode,iv) key = hkey, mode= cbc, iv= iv
    pt=  decipher.decrypt(not_original_file) #pt stands for plaintext. Use the key, mode, and iv to decrypt the ciphertext into plaintext 
    with open(decrypted_file, 'wb') as e:
        e.write(pt.rstrip(b'}')) #rstrip() to remove padding on file. If we don't remove padding the file will be corrupted
        
plaintext = decrypt_file(cipher_text) # will execute our decrypt funtion and will create decrypted file



    
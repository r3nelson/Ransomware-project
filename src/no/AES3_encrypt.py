from Crypto.Cipher import AES 
from Crypto.Hash import SHA256
import datetime

'''
you need to add cha cha in entierty
you need to fix aes ctr mode
you need to adjust file saved with params for decryption
you need to adjust decryption 
'''

print('no inputs will be case sensitive')
# AES only excepts key lengths of 16 (128 bits),24(196 bits),32(256 bits) byte so use SHA256 to stretch key to 32 byte value
password = datetime.datetime.today() # generate the current date and time as a datetime object 
password = str(password) #convert the datetime object to a string so we can hash it
hash_obj = SHA256.new(password.encode('utf-8')) #use the encode feature to turn the vairble password from a string to bytes. Actually it will be bytes but techically will be a type Sha256 object
hkey= hash_obj.hexdigest() # we are taking the hashed datetime and making it into a hexdigest which will be len(64)

encryption_algorithm = input('AES or CHACHA\n').lower()

while encryption_algorithm == 'aes': 
    key_size = int(input('enter what keysize you want: 128,196,or 256\n'))         
    if key_size == 256:
        hkey= hkey[len(hkey)::-2]
        break
    elif key_size == 196:
        hkey= hkey[len(hkey):31:-1]
        break
    elif key_size == 128:
        hkey= hkey[len(hkey)::-4]
        break
    else:
        print('you did not enter an acceptable key size')



 # we are reversing the hexdigest and stepping by 2 just for added security
hkey = hkey.encode('utf-8')

iv = hash_obj.digest() # we are creating an iv from the hashed datetime, and we are using digest instead of hexdigest so the iv and hkey are not too similar. 
iv = iv[len(iv)::-2] # reverse the iv (the hash_obj that's been digested) and slice the index by increments of 2 to generate an len(16) iv.

# random iv generated by datetime hash. IV must be blocksize bytes long. If statements will ensure iv is blocksize long. 
# this whole if statement used to add padding to inputted iv. I could delete it but keeping it acts as a safeguard incase the iv
# is ever not len(16) which I can't imagine why that would ever happen but still.
if len(iv) == 16:
    if len(hkey) ==32:
        pass 
elif len(iv) > 16:
    iv = iv[0:16]
elif len(iv)< 16:
    while len(iv) < 16:
        iv = iv + "{"

file = input('enter the name of the file you want encrypted:\n') # name of file to be encrypted
#encrypted_file  = 'Encrypted' + ' ' + file #name the file to be encrytpted Encrypted + a space + the name of the inital file
#decrypted_file = 'Decrypted' + ' ' + file #name the file to be decrytpted Decrypted + a space + the name of the inital file


while True:
    mode = input("'cbc', 'ctr','ofb','cfb'\n").lower() # will have to add mode to file that has key and iv 
    if mode == 'cbc': 
        mode = AES.MODE_CBC
        break
    elif mode == 'ctr':
        mode = AES.MODE_CTR
        break
    elif mode == 'ofb':
        mode = AES.MODE_OFB
        break
    elif mode == 'cfb':
        mode = AES.MODE_OFB
        break
    else:
        print('you did not enter an acceptable mode')

if __name__ == "__main__":
    with open('Save for decrypt.txt','wb') as f:
        necessary_for_decryption = [bytes(int(key_size/8)), b'\n', bytes(mode), b'\n', iv, b'\n', hkey]
        f.writelines(necessary_for_decryption)
        print(f'keysize is {key_size/8}')
        print(f'bytes int keysize is {bytes(int(key_size/8))}')
        print(f'mode is {mode}')
        print(f'bytes mode is {bytes(mode)}')
        print(f'iv is {iv}')
        print(f'hkey is {hkey}')

    def encrypt_file(file): # make encryption function
        with open(file, 'rb') as f: # file is the file to be encrypted we defined above. 'rb' stands for read bytes
            original_file = f.read()    # will read every line of the file
        BLOCK_SIZE = 16 # Block size is dependednt on encryption algorthim used for AES it is 16
        PAD = b'{' # the b is like the bytes version of the string. This will pad the file with "{" until it has symmetric block sizes of 16 bytes
        padding = lambda x: x + (BLOCK_SIZE-len(x) % BLOCK_SIZE) * PAD # will ensure the file is padded if it is not already in blocks of 16 bytes. See notes if this line does't make sense
        if mode == AES.MODE_CTR:
            cipher = AES.new(hkey,mode)
        else:
            cipher= AES.new(hkey,mode,iv) #standard notation for encryption is [encryption method used].new(key,mode,iv) key = hkey, mode= cbc, iv= iv
        result = cipher.encrypt(padding(original_file)) # encrypt original file with padding. Techincally we are actually encrypting a copy of the original file. Might need to delete original file
        with open(file,'wb') as e: #create a file with same name as before plus encrypted and enable it to be editted
            e.write(result) # write result, which is our encyrption to our newly created file


    cipher_text = encrypt_file(file) # this will convert file to bytes. It is no longer a string. Will create encrypted file




    